{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Start","text":"<p>This site contains the project documentation for the Final Project \"CS50 Introduction to Programming with Python\". It is a script that synchronize events in Google Calendars.</p> <p>Requirements:  </p> <ul> <li>Project must be implemented in Python.</li> <li>Project must have a <code>main</code> function and three or more additional functions. At least three of those additional funtions must be accompanied by test that can be executed with pytest.<ul> <li>Your <code>main</code> function must be in a file called <code>project.py</code>, which should be in the \u201croot\u201d (i.e., top-level folder) of your project.</li> <li>Your 3 required custom functions other than <code>main</code> must also be in <code>project.py</code> and defined at the same indentation level as <code>main</code> (i.e., not nested under any classes or functions).</li> <li>Your test functions must be in a file called <code>test_project.py</code>, which should also be in the \u201croot\u201d of your project. Be sure they have the same name as your custom functions, prepended with <code>test_</code> (<code>test_custom_function</code>, for example, where <code>custom_function</code> is a function you\u2019ve implemented in <code>project.py</code>).</li> <li>You are welcome to implement additional classes and functions as you see fit beyond the minimum requirement.</li> </ul> </li> <li>Implementing your project should entail more time and effort than is required by each of the course\u2019s problem sets.</li> <li>Any <code>pip</code>-installable libraries that your project requires must be listed, one per line, in a file called <code>requirements.txt</code> in the root of your project.</li> </ul> <p>Made by Tomasz Wo\u0142k. June 2025</p>"},{"location":"config/","title":"Config Class","text":"<p>Config class module</p> <p>This class set up configuration to manage application settings and Google Calendar API.</p> Pip install requires <ul> <li>google.auth.transport.requests</li> <li>google.oauth2.credentials</li> <li>google_auth_oauthlib.flow</li> <li>validator_collection</li> </ul>"},{"location":"config/#project_config_class.Config","title":"<code>Config</code>","text":"<p>Configuration class to manage application settings and Google Calendar API tokens.</p> <p>This class reads configuration from a file, manages OAuth 2.0 credentials, and provides methods to create and refresh tokens for accessing the Google Calendar API.  </p> <p>If run directly it will create or refresh tokens.  </p> <p>Attributes:</p> Name Type Description <code>scopes</code> <code>list</code> <p>List of OAuth 2.0 scopes for the Google Calendar API.</p> <code>calendar_id</code> <code>str</code> <p>The ID of the calendar to be accessed.</p> <code>target_calendar_id</code> <code>str</code> <p>The ID of the target calendar for synchronization.</p> <code>webhook_url</code> <code>str</code> <p>The URL to which notifications will be sent.</p> <code>prefix</code> <code>Optional[str]</code> <p>Optional prefix for event summaries.</p> <code>color</code> <code>Optional[str]</code> <p>Optional color for event summaries.</p> <code>suffix</code> <code>Optional[str]</code> <p>Optional suffix for event description.</p> <code>same_user</code> <code>bool</code> <p>Flag indicating whether to use the same user for both calendars.</p> <code>token_path</code> <code>Path</code> <p>Path to the token file for the master calendar.</p> <code>target_token_path</code> <code>Path</code> <p>Path to the token file for the target calendar.</p> <code>credentials_path</code> <code>Path</code> <p>Path to the credentials file for OAuth 2.0 authentication.</p> <code>os.environ[\"GOOGLE_APPLICATION_CREDENTIALS\"]</code> <code>Path</code> <p>Update Environment Variable</p> This class contains following methods <ul> <li>create_token(token_path, credentials_path, credentials, scopes) -      Creates the OAuth 2.0 token for accessing the Google Calendar API.</li> </ul> Source code in <code>project_config_class.py</code> <pre><code>class Config:\n    \"\"\"Configuration class to manage application settings and Google Calendar API tokens.\n\n    This class reads configuration from a file, manages OAuth 2.0 credentials, and provides\n    methods to create and refresh tokens for accessing the Google Calendar API.  \n\n    If run directly it will create or refresh tokens.  \n\n    Attributes:\n        scopes (list): List of OAuth 2.0 scopes for the Google Calendar API.\n        calendar_id (str): The ID of the calendar to be accessed.\n        target_calendar_id (str): The ID of the target calendar for synchronization.\n        webhook_url (str): The URL to which notifications will be sent.\n        prefix (Optional[str]): Optional prefix for event summaries.\n        color (Optional[str]): Optional color for event summaries.\n        suffix (Optional[str]): Optional suffix for event description.\n        same_user (bool): Flag indicating whether to use the same user for both calendars.\n        token_path (Path): Path to the token file for the master calendar.\n        target_token_path (Path): Path to the token file for the target calendar.\n        credentials_path (Path): Path to the credentials file for OAuth 2.0 authentication.\n        os.environ[\"GOOGLE_APPLICATION_CREDENTIALS\"]: Update Environment Variable\n\n    This class contains following methods:\n        - create_token(token_path, credentials_path, credentials, scopes) - \n            Creates the OAuth 2.0 token for accessing the Google Calendar API.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self.folder_path, self.config_file_path = self.get_paths()\n        self.config = configparser.ConfigParser()\n        self.config.read(self.config_file_path)\n\n        self.scopes: list = json.loads(self.config.get(\"configuration\", \"SCOPES\"))\n        if not isinstance(self.scopes, list) or not all(\n            checkers.is_url(scope) for scope in self.scopes\n        ):\n            raise ValueError(\"SCOPES must be a list of valid URLs.\")\n        self.calendar_id: str = self.config.get(\"configuration\", \"CALENDAR_ID\")\n        if not checkers.is_email(self.calendar_id):\n            raise ValueError(\n                f\"Invalid CALENDAR_ID: {self.calendar_id}. \"\n                \"Must be a valid email address.\"\n            )\n        self.target_calendar_id: str = self.config.get(\n            \"configuration\", \"TARGET_CALENDAR_ID\"\n        )\n        if not checkers.is_email(self.target_calendar_id):\n            raise ValueError(\n                f\"Invalid TARGET_CALENDAR_ID: {self.target_calendar_id}. \"\n                \"Must be a valid email address.\"\n            )\n        self.webhook_url: str = self.config.get(\"configuration\", \"WEBHOOK_URL\")\n        if not checkers.is_url(self.webhook_url) or not self.webhook_url.startswith(\n            \"https://\"\n        ):\n            raise ValueError(\n                f\"Invalid WEBHOOK_URL: {self.webhook_url}. Must be a valid HTTPS URL.\"\n            )\n        self.prefix: Optional[str] = self.config.get(\n            \"configuration\", \"PREFIX\", fallback=None\n        )\n        self.color: Optional[str] = self.config.get(\n            \"configuration\", \"COLOR\", fallback=None\n        )\n        self.suffix: Optional[str] = self.config.get(\n            \"configuration\", \"SUFFIX\", fallback=None\n        )\n        self.same_user: bool = self.config.getboolean(\n            \"configuration\", \"SAME_USER\", fallback=False\n        )\n        self.token_path = self.folder_path / self.config.get(\n            \"configuration\", \"TOKEN_PATH\"\n        )\n        self.target_token_path = self.folder_path / self.config.get(\n            \"configuration\", \"TARGET_TOKEN_PATH\"\n        )\n        self.credentials_path = self.folder_path / self.config.get(\n            \"configuration\", \"CREDENTIALS_PATH\"\n        )\n        os.environ[\"GOOGLE_APPLICATION_CREDENTIALS\"] = self.config.get(\n            \"configuration\", \"GOOGLE_APPLICATION_CREDENTIALS\"\n        )\n\n    def create_token(\n        self,\n        token_path: Path,\n        credentials_path: Path,\n        credentials,\n    ) -&gt; str:\n        \"\"\"Creates a token for the Google Calendar API.\n\n        This method is implementation from https://developers.google.com/people/quickstart/python  \n        Link above also shows how to enable Google Calendar API and how to create OAuth 2.0 creds.  \n        It checks if the token file exists and is valid. If not, it prompts the user to log in\n        and saves the new credentials to the token file.  \n\n        Args:\n            token_path: Path to the token file.\n            credentials_path: Path to the credentials file.\n            credentials (object): OAuth 2.0 credentials object.\n\n        Returns:\n            Credentials object containing the access token.\n        \"\"\"\n\n        # --- Load OAuth 2.0 Credentials ---\n        if os.path.exists(token_path):\n            credentials = Credentials.from_authorized_user_file(token_path, self.scopes)\n        # If there are no (valid) credentials available, let the user log in.\n        if not credentials or not credentials.valid:\n            if credentials and credentials.expired and credentials.refresh_token:\n                credentials.refresh(Request())\n            else:\n                flow = InstalledAppFlow.from_client_secrets_file(\n                    credentials_path, self.scopes\n                )\n                credentials = flow.run_local_server(port=0)\n            # Save the credentials for the next run\n            with open(token_path, \"w\", encoding=\"utf-8\") as token:\n                token.write(credentials.to_json())\n\n        return credentials  # type: ignore[import-untyped]\n\n    def get_paths(self) -&gt; tuple[Path, Path]:\n        \"\"\"Function get absolute path to folder and config.ini and checks if file exists.\n\n        Returns:\n            path to parent folder and configuration file 'config.ini'\n        \"\"\"\n\n        # Absolute path to the folder containing config.ini and token files.\n        folder_path = Path(__file__).parent.resolve()\n        # When using PythonAnywhere, can't use \"Path(__file__).resolve()\" because it returns wrong\n        # path. That's why I add \"config.ini\" to the folder_path\n        config_file_path = folder_path / \"config.ini\"\n        if not config_file_path.exists():\n            raise FileNotFoundError(\n                f\"Configuration file not found at {config_file_path}\"\n            )\n        return folder_path, config_file_path\n</code></pre>"},{"location":"config/#project_config_class.Config.create_token","title":"<code>create_token(token_path, credentials_path, credentials)</code>","text":"<p>Creates a token for the Google Calendar API.</p> <p>This method is implementation from https://developers.google.com/people/quickstart/python Link above also shows how to enable Google Calendar API and how to create OAuth 2.0 creds. It checks if the token file exists and is valid. If not, it prompts the user to log in and saves the new credentials to the token file.  </p> <p>Parameters:</p> Name Type Description Default <code>token_path</code> <code>Path</code> <p>Path to the token file.</p> required <code>credentials_path</code> <code>Path</code> <p>Path to the credentials file.</p> required <code>credentials</code> <code>object</code> <p>OAuth 2.0 credentials object.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Credentials object containing the access token.</p> Source code in <code>project_config_class.py</code> <pre><code>def create_token(\n    self,\n    token_path: Path,\n    credentials_path: Path,\n    credentials,\n) -&gt; str:\n    \"\"\"Creates a token for the Google Calendar API.\n\n    This method is implementation from https://developers.google.com/people/quickstart/python  \n    Link above also shows how to enable Google Calendar API and how to create OAuth 2.0 creds.  \n    It checks if the token file exists and is valid. If not, it prompts the user to log in\n    and saves the new credentials to the token file.  \n\n    Args:\n        token_path: Path to the token file.\n        credentials_path: Path to the credentials file.\n        credentials (object): OAuth 2.0 credentials object.\n\n    Returns:\n        Credentials object containing the access token.\n    \"\"\"\n\n    # --- Load OAuth 2.0 Credentials ---\n    if os.path.exists(token_path):\n        credentials = Credentials.from_authorized_user_file(token_path, self.scopes)\n    # If there are no (valid) credentials available, let the user log in.\n    if not credentials or not credentials.valid:\n        if credentials and credentials.expired and credentials.refresh_token:\n            credentials.refresh(Request())\n        else:\n            flow = InstalledAppFlow.from_client_secrets_file(\n                credentials_path, self.scopes\n            )\n            credentials = flow.run_local_server(port=0)\n        # Save the credentials for the next run\n        with open(token_path, \"w\", encoding=\"utf-8\") as token:\n            token.write(credentials.to_json())\n\n    return credentials  # type: ignore[import-untyped]\n</code></pre>"},{"location":"config/#project_config_class.Config.get_paths","title":"<code>get_paths()</code>","text":"<p>Function get absolute path to folder and config.ini and checks if file exists.</p> <p>Returns:</p> Type Description <code>tuple[Path, Path]</code> <p>path to parent folder and configuration file 'config.ini'</p> Source code in <code>project_config_class.py</code> <pre><code>def get_paths(self) -&gt; tuple[Path, Path]:\n    \"\"\"Function get absolute path to folder and config.ini and checks if file exists.\n\n    Returns:\n        path to parent folder and configuration file 'config.ini'\n    \"\"\"\n\n    # Absolute path to the folder containing config.ini and token files.\n    folder_path = Path(__file__).parent.resolve()\n    # When using PythonAnywhere, can't use \"Path(__file__).resolve()\" because it returns wrong\n    # path. That's why I add \"config.ini\" to the folder_path\n    config_file_path = folder_path / \"config.ini\"\n    if not config_file_path.exists():\n        raise FileNotFoundError(\n            f\"Configuration file not found at {config_file_path}\"\n        )\n    return folder_path, config_file_path\n</code></pre>"},{"location":"event_data/","title":"Event Data","text":"<p>Event Data Class module</p> <p>This class allows user to create, modyfi or delete events in Google Calendar.</p> <p>Script requires googleapiclient.errors.</p> <p>This module contains class EventData.</p>"},{"location":"event_data/#project_event_data.EventData","title":"<code>EventData</code>","text":"<p>Class to handle event data for Google Calendar API operations.</p> <p>This class is responsible for creating, updating, and managing Google Calendar event data.    </p> <p>Attributes:</p> Name Type Description <code>data</code> <code>dict</code> <p>A dictionary to store event data,             which is populated by the get_event details method.  </p> This class contains following methods <ul> <li>create_new_event(calendar_id, target_service, send_updates) -      Creates a new event in the specified calendar using the Google Calendar API.  </li> <li>update_event(target_service, target_event_id) -      Updates an existing event in the target calendar using the Google Calendar API.  </li> <li>get_event_details(event) -      Copies all event data to self.data and modifies or adds additional information      from config.ini.  </li> <li>pop_unnecessary_keys() -      Removes keys from the event data that are not required      or may cause errors during event creation or update.  </li> <li>get_attendee_response_status(event, email) -      Get invitation response status if there are attendees.  </li> <li>check_if_id_exists_in_target_calendar(event_id, target_service) -      Checks if an event with the given ID exists in the target calendar.  </li> <li>delete_event(calendar_id, event_id, target_service) -      Deletes an event from the specified calendar using the Google Calendar API.  </li> <li>check_calendars_in_attendees(event) -      Check if main or target calendars are in the event attendees.</li> </ul> Source code in <code>project_event_data.py</code> <pre><code>class EventData:\n    \"\"\"Class to handle event data for Google Calendar API operations.\n\n    This class is responsible for creating, updating, and managing Google Calendar event data.    \n\n    Attributes:\n        data (dict): A dictionary to store event data,\n                        which is populated by the get_event details method.  \n\n    This class contains following methods:\n        - create_new_event(calendar_id, target_service, send_updates) - \n            Creates a new event in the specified calendar using the Google Calendar API.  \n        - update_event(target_service, target_event_id) - \n            Updates an existing event in the target calendar using the Google Calendar API.  \n        - get_event_details(event) - \n            Copies all event data to self.data and modifies or adds additional information \n            from config.ini.  \n        - pop_unnecessary_keys() - \n            Removes keys from the event data that are not required \n            or may cause errors during event creation or update.  \n        - get_attendee_response_status(event, email) - \n            Get invitation response status if there are attendees.  \n        - check_if_id_exists_in_target_calendar(event_id, target_service) - \n            Checks if an event with the given ID exists in the target calendar.  \n        - delete_event(calendar_id, event_id, target_service) - \n            Deletes an event from the specified calendar using the Google Calendar API.  \n        - check_calendars_in_attendees(event) - \n            Check if main or target calendars are in the event attendees.  \n    \"\"\"\n\n    def __init__(self):\n        self.data = {}\n\n    def create_new_event(\n        self, calendar_id: str, target_service, send_updates: str = \"none\"\n    ) -&gt; None:\n        \"\"\"Creates a new event in the specified calendar.\n\n        This method uses the Google Calendar API to insert a new event into the target calendar.  \n        It takes event data from the instance's 'data' - created by get_event_details method.  \n        It also supports attachments and conference data,\n            and by default does not send updates to attendees.\n\n        Args:\n            calendar_id: The ID of the calendar to create the event in target calendar\n            target_service (service instance): The Google Calendar API service instance\n                                used to interact with the calendar\n            send_updates: Who gets information about changes in the event.  \n                Options:  \n                    - all  \n                    - externalOnly  \n                    - none  \n        \"\"\"\n\n        Logger().debug(\n            f\"Creating event with summary: {self.data.get('summary', 'No summary')}, \"\n            f\"ID: {self.data.get('id', 'Unknown ID')}.\", __name__\n        )\n        try:\n            event = (\n                target_service.events()\n                .insert(\n                    calendarId=calendar_id,\n                    body=self.data,\n                    conferenceDataVersion=1,\n                    supportsAttachments=True,\n                    sendUpdates=send_updates,\n                )\n                .execute()\n            )\n            Logger().info(f\"Event created: {event.get('htmlLink')}\\n{self.data}\\n\", __name__)\n        except HttpError as e:\n            Logger().error(\n                f\"HttpError creating event, ID: {self.data.get('id', 'Unknown ID')}\",\n                f\"error: {e}.\", __name__\n            )\n        except Exception as e:\n            Logger.error(\n                f\"Error creating event, ID: {self.data.get('id', 'Unknown ID')}, err: {e}.\",__name__\n            )\n\n    def update_event(self, target_service, target_event_id: str, config) -&gt; None:\n        \"\"\"Updates existing event in target calendar.\n\n        This method uses the Google Calendar API to update event in the target calendar.\n        It takes event data from the instance's 'data' attribute - created by get_event_details.\n        If the 'target_event_id' is not found in the target calendar, error is printed.\n        It also supports attachments and conference data, and does not send updates to attendees.\n\n        Args:\n            target_service (service instance): The Google Calendar API service instance\n                                used to interact with the calendar\n            target_event_id: The ID of the event to update in the target calendar\n            config (instance): Instance of configuration class to manage application settings and \n                Google Calendar API tokens.\n        \"\"\"\n\n        try:\n            target_service.events().update(\n                calendarId=config.target_calendar_id,\n                eventId=target_event_id,\n                body=self.data,\n                conferenceDataVersion=1,\n                supportsAttachments=True,\n                sendUpdates=\"none\",\n            ).execute()\n            Logger().info(\n                f\"Event: {self.data.get('summary', 'No summary')}, \"\n                f\"ID: {target_event_id} has been updated.\", __name__\n            )\n        except Exception as e:\n            Logger.error(\n                f\"Error updating event {self.data.get('summary', 'No summary')}, \"\n                f\"ID: {target_event_id}: {e}\", __name__\n            )\n\n    def get_event_details(self, event: dict, config) -&gt; None:\n        \"\"\"Copies all event data to self.data and modify or add information from config.ini.\n\n        It is used to prepare event data for creating or updating an event in the target calendar.\n        This method modifies the event data by adding a prefix to the summary if in the config.ini.\n        It also adds a colorId if it exists in the config.ini and appends a description -\n            information that it was created by a script - if it is not already present.\n\n        Args:\n            event (dict): The event data\n            config (instance): Instance of configuration class to manage application settings and \n                Google Calendar API tokens.\n        \"\"\"\n\n        self.data = event.copy()\n        # Add prefix to summary if it exists in config.ini\n        if config.prefix:\n            event_summary = event.get(\"summary\", \"\")\n            if not event_summary.startswith(config.prefix):\n                self.data[\"summary\"] = f\"{config.prefix} {event_summary}\"\n        # Add colorId if it exists in config.ini\n        if config.color:\n            self.data[\"colorId\"] = config.color\n        # Add description if it already is not added.\n        description_added = config.suffix\n        description = event.get(\"description\", \"\")\n        # Checks if already added - this is to avoid adding the same description multiple times.\n        if description_added not in description:\n            # strip() is used to remove added \\n\\n if originaly there is no description.\n            self.data[\"description\"] = (\n                description + \"\\n\\n\" + description_added\n            ).strip()\n\n    def pop_unnecessary_keys(self) -&gt; None:\n        \"\"\"Removes keys from the event data that are not required or may cause errors.\n\n        The excluded keys are typically metadata or system-generated fields that are not necessary \n        for creating or updating events in the target calendar:  \n\n        - \"originalStartTime\", \"recurringEventId\": These are related to recurring events and\n                    may conflict with new event creation.  \n        - \"created\", \"creator\", \"etag\", \"htmlLink\", \"kind\", \"organizer\", \"sequence\", \"updated\":\n                    These are system-generated fields that are not modifiable.  \n        - \"iCalUID\": This is a unique identifier for the event in iCalendar format.\n                    Can't use if 'id' is passed to the API.  \n        \"\"\"\n\n        keys_to_pop = (\n            \"created\",\n            \"creator\",\n            \"etag\",\n            \"htmlLink\",\n            \"iCalUID\",\n            \"kind\",\n            \"originalStartTime\",\n            \"organizer\",\n            \"recurringEventId\",\n            \"sequence\",\n            \"updated\",\n        )\n        try:\n            self.data = {\n                key: value for key, value in self.data.items() if key not in keys_to_pop\n            }\n        except Exception as e:\n            Logger().error(f\"Exception pop_unnecessary_keys: {e}\", __name__)\n\n    @staticmethod\n    def get_attendee_response_status(event: dict, email: str) -&gt; Optional[str]:\n        \"\"\"Get invitation response status if there are attendees.\n\n        Email address is taken from Config.CALENDAR_ID or Config.TARGET_CALENDAR_ID.\n\n        Args:\n            event: The event data\n            email: The email address of the attendee whose response status is to be checked\n\n        Returns:\n            'needsAction' - invitation not accepted (default) -&gt;\n                create new event or do nothing if event already created\n            'declined' - invitation declined -&gt;\n                delete the event (it was created when the invitation was received)\n            'tentative' - the invitation is being considered -&gt;\n                create new event or do nothing if event already created\n            'accepted' - invitation accepted -&gt;\n                create new event or do nothing if event already created\n        \"\"\"\n\n        try:\n            attendees = event.get(\"attendees\")\n            response_status = None\n            if attendees is not None:\n                for attendee in attendees:\n                    if attendee.get(\"email\") == email:\n                        return attendee.get(\"responseStatus\", None)\n            return response_status\n        except AttributeError as e:\n            Logger().error(\n                f\"AttributeError getting response status. ID: {event.get('id')} - {e}.\", __name__\n            )\n            return None\n        except Exception as e:\n            Logger().error(\n                f\"Exception getting response status. ID: {event.get('id')} - {e}.\", __name__\n            )\n            return None\n\n    @staticmethod\n    def check_if_id_exists_in_target_calendar(\n        event_id: str, target_service, config\n    ) -&gt; Optional[dict]:\n        \"\"\"Checks if an event with the given ID exists in the target calendar.\n\n        Args:\n            event_id: The event ID to check in the target calendar\n            target_service (service instance): The Google Calendar API service instance\n                                used to interact with the calendar\n            config (instance): Instance of configuration class to manage application settings and \n                Google Calendar API tokens.\n\n        Returns:\n            dict: The event data from the target calendar if it exists\n            None: If the event does not exist in the target calendar or if an error occurs\n        \"\"\"\n\n        try:\n            target_event = (\n                target_service.events()\n                .get(calendarId=config.target_calendar_id, eventId=event_id)\n                .execute()\n            )\n            return target_event\n        except HttpError:\n            Logger.info(f\"Event ID: {event_id} doesn't exist in target calendar\", __name__)\n            return None\n\n    @staticmethod\n    def delete_event(calendar_id: str, event_id: str, target_service) -&gt; None:\n        \"\"\"Deletes an event from the specified calendar.\n\n        Args:\n            calendar_id: The ID of the calendar from which to delete the event\n            event_id: The ID of the event to delete\n            target_service (service instance): The Google Calendar API service instance\n                                used to interact with the calendar\n        \"\"\"\n\n        try:\n            target_service.events().delete(\n                calendarId=calendar_id, eventId=event_id\n            ).execute()\n            Logger().info(f\"Event ID: {event_id} deleted\", __name__)\n        except HttpError as e:\n            Logger().error(f\"HttpError deleting event {event_id}: {e}.\", __name__)\n        except Exception as e:\n            Logger().error(f\"Error deleting event {event_id}: {e}.\", __name__)\n\n    @staticmethod\n    def check_calendars_in_attendees(event: dict, config) -&gt; Optional[str]:\n        \"\"\"Check if main or target calendars are in the event attendees.\n\n        This function expects the \"event\" dictionary to have an optional \"attendees\" key,\n        which shoul be a list of dictionaries, each representing an attendee with an \"email\" key.\n\n        If both calendars are in the event attendees, then return \"Both\" and skip the event.  \n        If only main or target calendar is in the event attendees,\n        then return \"Main\" or \"Target\" and create or update the event.  \n        If none of the calendars are in the event attendees, then return None.\n\n        Args:\n            event (dict): The event data\n            config (instance): Instance of configuration class to manage application settings and \n                Google Calendar API tokens.\n\n        Returns:\n            str: \"Both\" | \"Main\" | \"Target\"\n            None: If neither calendar is in the event attendees\n        \"\"\"\n\n        calendar_id_in_attendees = False\n        target_calendar_id_in_attendees = False\n        try:\n            attendees = event.get(\"attendees\", [])\n            if not attendees:\n                return None\n            for attendee in attendees:\n                if attendee.get(\"email\", \"\") == config.calendar_id:\n                    calendar_id_in_attendees = True\n                if attendee.get(\"email\", \"\") == config.target_calendar_id:\n                    target_calendar_id_in_attendees = True\n\n            if calendar_id_in_attendees and target_calendar_id_in_attendees:\n                return \"Both\"\n            if calendar_id_in_attendees and not target_calendar_id_in_attendees:\n                return \"Main\"\n            if not calendar_id_in_attendees and target_calendar_id_in_attendees:\n                return \"Target\"\n            return None\n        except Exception as e:\n            Logger().error(\n                f\"Error checking attendees for event ID: {event.get('id')}. \"\n                f\"Summary: {event.get('summary', 'No summary')} - {e}\", __name__\n            )\n            return None\n</code></pre>"},{"location":"event_data/#project_event_data.EventData.check_calendars_in_attendees","title":"<code>check_calendars_in_attendees(event, config)</code>  <code>staticmethod</code>","text":"<p>Check if main or target calendars are in the event attendees.</p> <p>This function expects the \"event\" dictionary to have an optional \"attendees\" key, which shoul be a list of dictionaries, each representing an attendee with an \"email\" key.</p> <p>If both calendars are in the event attendees, then return \"Both\" and skip the event. If only main or target calendar is in the event attendees, then return \"Main\" or \"Target\" and create or update the event. If none of the calendars are in the event attendees, then return None.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>dict</code> <p>The event data</p> required <code>config</code> <code>instance</code> <p>Instance of configuration class to manage application settings and  Google Calendar API tokens.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>Optional[str]</code> <p>\"Both\" | \"Main\" | \"Target\"</p> <code>None</code> <code>Optional[str]</code> <p>If neither calendar is in the event attendees</p> Source code in <code>project_event_data.py</code> <pre><code>@staticmethod\ndef check_calendars_in_attendees(event: dict, config) -&gt; Optional[str]:\n    \"\"\"Check if main or target calendars are in the event attendees.\n\n    This function expects the \"event\" dictionary to have an optional \"attendees\" key,\n    which shoul be a list of dictionaries, each representing an attendee with an \"email\" key.\n\n    If both calendars are in the event attendees, then return \"Both\" and skip the event.  \n    If only main or target calendar is in the event attendees,\n    then return \"Main\" or \"Target\" and create or update the event.  \n    If none of the calendars are in the event attendees, then return None.\n\n    Args:\n        event (dict): The event data\n        config (instance): Instance of configuration class to manage application settings and \n            Google Calendar API tokens.\n\n    Returns:\n        str: \"Both\" | \"Main\" | \"Target\"\n        None: If neither calendar is in the event attendees\n    \"\"\"\n\n    calendar_id_in_attendees = False\n    target_calendar_id_in_attendees = False\n    try:\n        attendees = event.get(\"attendees\", [])\n        if not attendees:\n            return None\n        for attendee in attendees:\n            if attendee.get(\"email\", \"\") == config.calendar_id:\n                calendar_id_in_attendees = True\n            if attendee.get(\"email\", \"\") == config.target_calendar_id:\n                target_calendar_id_in_attendees = True\n\n        if calendar_id_in_attendees and target_calendar_id_in_attendees:\n            return \"Both\"\n        if calendar_id_in_attendees and not target_calendar_id_in_attendees:\n            return \"Main\"\n        if not calendar_id_in_attendees and target_calendar_id_in_attendees:\n            return \"Target\"\n        return None\n    except Exception as e:\n        Logger().error(\n            f\"Error checking attendees for event ID: {event.get('id')}. \"\n            f\"Summary: {event.get('summary', 'No summary')} - {e}\", __name__\n        )\n        return None\n</code></pre>"},{"location":"event_data/#project_event_data.EventData.check_if_id_exists_in_target_calendar","title":"<code>check_if_id_exists_in_target_calendar(event_id, target_service, config)</code>  <code>staticmethod</code>","text":"<p>Checks if an event with the given ID exists in the target calendar.</p> <p>Parameters:</p> Name Type Description Default <code>event_id</code> <code>str</code> <p>The event ID to check in the target calendar</p> required <code>target_service</code> <code>service instance</code> <p>The Google Calendar API service instance                 used to interact with the calendar</p> required <code>config</code> <code>instance</code> <p>Instance of configuration class to manage application settings and  Google Calendar API tokens.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>Optional[dict]</code> <p>The event data from the target calendar if it exists</p> <code>None</code> <code>Optional[dict]</code> <p>If the event does not exist in the target calendar or if an error occurs</p> Source code in <code>project_event_data.py</code> <pre><code>@staticmethod\ndef check_if_id_exists_in_target_calendar(\n    event_id: str, target_service, config\n) -&gt; Optional[dict]:\n    \"\"\"Checks if an event with the given ID exists in the target calendar.\n\n    Args:\n        event_id: The event ID to check in the target calendar\n        target_service (service instance): The Google Calendar API service instance\n                            used to interact with the calendar\n        config (instance): Instance of configuration class to manage application settings and \n            Google Calendar API tokens.\n\n    Returns:\n        dict: The event data from the target calendar if it exists\n        None: If the event does not exist in the target calendar or if an error occurs\n    \"\"\"\n\n    try:\n        target_event = (\n            target_service.events()\n            .get(calendarId=config.target_calendar_id, eventId=event_id)\n            .execute()\n        )\n        return target_event\n    except HttpError:\n        Logger.info(f\"Event ID: {event_id} doesn't exist in target calendar\", __name__)\n        return None\n</code></pre>"},{"location":"event_data/#project_event_data.EventData.create_new_event","title":"<code>create_new_event(calendar_id, target_service, send_updates='none')</code>","text":"<p>Creates a new event in the specified calendar.</p> <p>This method uses the Google Calendar API to insert a new event into the target calendar. It takes event data from the instance's 'data' - created by get_event_details method. It also supports attachments and conference data,     and by default does not send updates to attendees.</p> <p>Parameters:</p> Name Type Description Default <code>calendar_id</code> <code>str</code> <p>The ID of the calendar to create the event in target calendar</p> required <code>target_service</code> <code>service instance</code> <p>The Google Calendar API service instance                 used to interact with the calendar</p> required <code>send_updates</code> <code>str</code> <p>Who gets information about changes in the event. Options:     - all     - externalOnly     - none</p> <code>'none'</code> Source code in <code>project_event_data.py</code> <pre><code>def create_new_event(\n    self, calendar_id: str, target_service, send_updates: str = \"none\"\n) -&gt; None:\n    \"\"\"Creates a new event in the specified calendar.\n\n    This method uses the Google Calendar API to insert a new event into the target calendar.  \n    It takes event data from the instance's 'data' - created by get_event_details method.  \n    It also supports attachments and conference data,\n        and by default does not send updates to attendees.\n\n    Args:\n        calendar_id: The ID of the calendar to create the event in target calendar\n        target_service (service instance): The Google Calendar API service instance\n                            used to interact with the calendar\n        send_updates: Who gets information about changes in the event.  \n            Options:  \n                - all  \n                - externalOnly  \n                - none  \n    \"\"\"\n\n    Logger().debug(\n        f\"Creating event with summary: {self.data.get('summary', 'No summary')}, \"\n        f\"ID: {self.data.get('id', 'Unknown ID')}.\", __name__\n    )\n    try:\n        event = (\n            target_service.events()\n            .insert(\n                calendarId=calendar_id,\n                body=self.data,\n                conferenceDataVersion=1,\n                supportsAttachments=True,\n                sendUpdates=send_updates,\n            )\n            .execute()\n        )\n        Logger().info(f\"Event created: {event.get('htmlLink')}\\n{self.data}\\n\", __name__)\n    except HttpError as e:\n        Logger().error(\n            f\"HttpError creating event, ID: {self.data.get('id', 'Unknown ID')}\",\n            f\"error: {e}.\", __name__\n        )\n    except Exception as e:\n        Logger.error(\n            f\"Error creating event, ID: {self.data.get('id', 'Unknown ID')}, err: {e}.\",__name__\n        )\n</code></pre>"},{"location":"event_data/#project_event_data.EventData.delete_event","title":"<code>delete_event(calendar_id, event_id, target_service)</code>  <code>staticmethod</code>","text":"<p>Deletes an event from the specified calendar.</p> <p>Parameters:</p> Name Type Description Default <code>calendar_id</code> <code>str</code> <p>The ID of the calendar from which to delete the event</p> required <code>event_id</code> <code>str</code> <p>The ID of the event to delete</p> required <code>target_service</code> <code>service instance</code> <p>The Google Calendar API service instance                 used to interact with the calendar</p> required Source code in <code>project_event_data.py</code> <pre><code>@staticmethod\ndef delete_event(calendar_id: str, event_id: str, target_service) -&gt; None:\n    \"\"\"Deletes an event from the specified calendar.\n\n    Args:\n        calendar_id: The ID of the calendar from which to delete the event\n        event_id: The ID of the event to delete\n        target_service (service instance): The Google Calendar API service instance\n                            used to interact with the calendar\n    \"\"\"\n\n    try:\n        target_service.events().delete(\n            calendarId=calendar_id, eventId=event_id\n        ).execute()\n        Logger().info(f\"Event ID: {event_id} deleted\", __name__)\n    except HttpError as e:\n        Logger().error(f\"HttpError deleting event {event_id}: {e}.\", __name__)\n    except Exception as e:\n        Logger().error(f\"Error deleting event {event_id}: {e}.\", __name__)\n</code></pre>"},{"location":"event_data/#project_event_data.EventData.get_attendee_response_status","title":"<code>get_attendee_response_status(event, email)</code>  <code>staticmethod</code>","text":"<p>Get invitation response status if there are attendees.</p> <p>Email address is taken from Config.CALENDAR_ID or Config.TARGET_CALENDAR_ID.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>dict</code> <p>The event data</p> required <code>email</code> <code>str</code> <p>The email address of the attendee whose response status is to be checked</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>'needsAction' - invitation not accepted (default) -&gt; create new event or do nothing if event already created</p> <code>Optional[str]</code> <p>'declined' - invitation declined -&gt; delete the event (it was created when the invitation was received)</p> <code>Optional[str]</code> <p>'tentative' - the invitation is being considered -&gt; create new event or do nothing if event already created</p> <code>Optional[str]</code> <p>'accepted' - invitation accepted -&gt; create new event or do nothing if event already created</p> Source code in <code>project_event_data.py</code> <pre><code>@staticmethod\ndef get_attendee_response_status(event: dict, email: str) -&gt; Optional[str]:\n    \"\"\"Get invitation response status if there are attendees.\n\n    Email address is taken from Config.CALENDAR_ID or Config.TARGET_CALENDAR_ID.\n\n    Args:\n        event: The event data\n        email: The email address of the attendee whose response status is to be checked\n\n    Returns:\n        'needsAction' - invitation not accepted (default) -&gt;\n            create new event or do nothing if event already created\n        'declined' - invitation declined -&gt;\n            delete the event (it was created when the invitation was received)\n        'tentative' - the invitation is being considered -&gt;\n            create new event or do nothing if event already created\n        'accepted' - invitation accepted -&gt;\n            create new event or do nothing if event already created\n    \"\"\"\n\n    try:\n        attendees = event.get(\"attendees\")\n        response_status = None\n        if attendees is not None:\n            for attendee in attendees:\n                if attendee.get(\"email\") == email:\n                    return attendee.get(\"responseStatus\", None)\n        return response_status\n    except AttributeError as e:\n        Logger().error(\n            f\"AttributeError getting response status. ID: {event.get('id')} - {e}.\", __name__\n        )\n        return None\n    except Exception as e:\n        Logger().error(\n            f\"Exception getting response status. ID: {event.get('id')} - {e}.\", __name__\n        )\n        return None\n</code></pre>"},{"location":"event_data/#project_event_data.EventData.get_event_details","title":"<code>get_event_details(event, config)</code>","text":"<p>Copies all event data to self.data and modify or add information from config.ini.</p> <p>It is used to prepare event data for creating or updating an event in the target calendar. This method modifies the event data by adding a prefix to the summary if in the config.ini. It also adds a colorId if it exists in the config.ini and appends a description -     information that it was created by a script - if it is not already present.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>dict</code> <p>The event data</p> required <code>config</code> <code>instance</code> <p>Instance of configuration class to manage application settings and  Google Calendar API tokens.</p> required Source code in <code>project_event_data.py</code> <pre><code>def get_event_details(self, event: dict, config) -&gt; None:\n    \"\"\"Copies all event data to self.data and modify or add information from config.ini.\n\n    It is used to prepare event data for creating or updating an event in the target calendar.\n    This method modifies the event data by adding a prefix to the summary if in the config.ini.\n    It also adds a colorId if it exists in the config.ini and appends a description -\n        information that it was created by a script - if it is not already present.\n\n    Args:\n        event (dict): The event data\n        config (instance): Instance of configuration class to manage application settings and \n            Google Calendar API tokens.\n    \"\"\"\n\n    self.data = event.copy()\n    # Add prefix to summary if it exists in config.ini\n    if config.prefix:\n        event_summary = event.get(\"summary\", \"\")\n        if not event_summary.startswith(config.prefix):\n            self.data[\"summary\"] = f\"{config.prefix} {event_summary}\"\n    # Add colorId if it exists in config.ini\n    if config.color:\n        self.data[\"colorId\"] = config.color\n    # Add description if it already is not added.\n    description_added = config.suffix\n    description = event.get(\"description\", \"\")\n    # Checks if already added - this is to avoid adding the same description multiple times.\n    if description_added not in description:\n        # strip() is used to remove added \\n\\n if originaly there is no description.\n        self.data[\"description\"] = (\n            description + \"\\n\\n\" + description_added\n        ).strip()\n</code></pre>"},{"location":"event_data/#project_event_data.EventData.pop_unnecessary_keys","title":"<code>pop_unnecessary_keys()</code>","text":"<p>Removes keys from the event data that are not required or may cause errors.</p> <p>The excluded keys are typically metadata or system-generated fields that are not necessary  for creating or updating events in the target calendar:  </p> <ul> <li>\"originalStartTime\", \"recurringEventId\": These are related to recurring events and             may conflict with new event creation.  </li> <li>\"created\", \"creator\", \"etag\", \"htmlLink\", \"kind\", \"organizer\", \"sequence\", \"updated\":             These are system-generated fields that are not modifiable.  </li> <li>\"iCalUID\": This is a unique identifier for the event in iCalendar format.             Can't use if 'id' is passed to the API.</li> </ul> Source code in <code>project_event_data.py</code> <pre><code>def pop_unnecessary_keys(self) -&gt; None:\n    \"\"\"Removes keys from the event data that are not required or may cause errors.\n\n    The excluded keys are typically metadata or system-generated fields that are not necessary \n    for creating or updating events in the target calendar:  \n\n    - \"originalStartTime\", \"recurringEventId\": These are related to recurring events and\n                may conflict with new event creation.  \n    - \"created\", \"creator\", \"etag\", \"htmlLink\", \"kind\", \"organizer\", \"sequence\", \"updated\":\n                These are system-generated fields that are not modifiable.  \n    - \"iCalUID\": This is a unique identifier for the event in iCalendar format.\n                Can't use if 'id' is passed to the API.  \n    \"\"\"\n\n    keys_to_pop = (\n        \"created\",\n        \"creator\",\n        \"etag\",\n        \"htmlLink\",\n        \"iCalUID\",\n        \"kind\",\n        \"originalStartTime\",\n        \"organizer\",\n        \"recurringEventId\",\n        \"sequence\",\n        \"updated\",\n    )\n    try:\n        self.data = {\n            key: value for key, value in self.data.items() if key not in keys_to_pop\n        }\n    except Exception as e:\n        Logger().error(f\"Exception pop_unnecessary_keys: {e}\", __name__)\n</code></pre>"},{"location":"event_data/#project_event_data.EventData.update_event","title":"<code>update_event(target_service, target_event_id, config)</code>","text":"<p>Updates existing event in target calendar.</p> <p>This method uses the Google Calendar API to update event in the target calendar. It takes event data from the instance's 'data' attribute - created by get_event_details. If the 'target_event_id' is not found in the target calendar, error is printed. It also supports attachments and conference data, and does not send updates to attendees.</p> <p>Parameters:</p> Name Type Description Default <code>target_service</code> <code>service instance</code> <p>The Google Calendar API service instance                 used to interact with the calendar</p> required <code>target_event_id</code> <code>str</code> <p>The ID of the event to update in the target calendar</p> required <code>config</code> <code>instance</code> <p>Instance of configuration class to manage application settings and  Google Calendar API tokens.</p> required Source code in <code>project_event_data.py</code> <pre><code>def update_event(self, target_service, target_event_id: str, config) -&gt; None:\n    \"\"\"Updates existing event in target calendar.\n\n    This method uses the Google Calendar API to update event in the target calendar.\n    It takes event data from the instance's 'data' attribute - created by get_event_details.\n    If the 'target_event_id' is not found in the target calendar, error is printed.\n    It also supports attachments and conference data, and does not send updates to attendees.\n\n    Args:\n        target_service (service instance): The Google Calendar API service instance\n                            used to interact with the calendar\n        target_event_id: The ID of the event to update in the target calendar\n        config (instance): Instance of configuration class to manage application settings and \n            Google Calendar API tokens.\n    \"\"\"\n\n    try:\n        target_service.events().update(\n            calendarId=config.target_calendar_id,\n            eventId=target_event_id,\n            body=self.data,\n            conferenceDataVersion=1,\n            supportsAttachments=True,\n            sendUpdates=\"none\",\n        ).execute()\n        Logger().info(\n            f\"Event: {self.data.get('summary', 'No summary')}, \"\n            f\"ID: {target_event_id} has been updated.\", __name__\n        )\n    except Exception as e:\n        Logger.error(\n            f\"Error updating event {self.data.get('summary', 'No summary')}, \"\n            f\"ID: {target_event_id}: {e}\", __name__\n        )\n</code></pre>"},{"location":"google_app_cred/","title":"Google Application Credentials","text":"<p>It's a environment variable that is used to specify the location of a JSON file that contains your  Google Cloud service account key. This environment variable is essential for authenticating your  application to Google Cloud services using Application Default Credentials (ADC).  </p>"},{"location":"google_app_cred/#setting-up-google_application_credentials","title":"Setting Up GOOGLE_APPLICATION_CREDENTIALS","text":"<p>To set up the GOOGLE_APPLICATION_CREDENTIALS environment variable, follow these steps:  </p> <ol> <li> <p>Create a Service Account:  </p> <ul> <li>Go to the Google Cloud Console.  </li> <li>Navigate to IAM &amp; Admin &gt; Service Accounts.  </li> <li>Click Create Service Account.  </li> <li>Fill in the service account details and click Create and continue.  </li> <li>Assign roles to the service account as needed.  </li> <li>Click Done.  </li> </ul> </li> <li> <p>Generate a Service Account Key:  </p> <ul> <li>Select your service account from the list. </li> <li>Click Keys &gt; Add Key &gt; Create new key. </li> <li>Choose JSON and click Create. </li> <li>Save the downloaded JSON file to a secure location.</li> </ul> </li> <li> <p>Update in config.ini in GOOGLE_APPLICATION_CREDENTIALS path to downloaded JSON file.</p> <p><code>GOOGLE_APPLICATION_CREDENTIALS = /path/to/your/service-account-file.json</code></p> </li> </ol>"},{"location":"google_cloud/","title":"Google Cloud Project","text":"<p>To create new Google Cloud project with Calendar API follow this steps:</p> <ol> <li> <p>Open project picker (ctrl + O) &gt; New project</p> <ul> <li>Enter Project name</li> <li>Choose Location (if applicable)</li> <li>Create</li> </ul> </li> <li> <p>In navigation menu (.):</p> <ul> <li>APIs &amp; Services<ul> <li>Enable APIs &amp; services</li> <li>+ Enable APIs and services</li> <li>choose Google Calendar API</li> <li>Enable</li> </ul> </li> <li>Credentials<ul> <li>+ Create credentials &gt; OAuth client ID</li> <li>Application type: Desktop app &gt; Enter name &gt; Create</li> <li>Download JSON as \"credentials.json\" to folder where your script is</li> </ul> </li> <li>OAuth consent screen<ul> <li>Audience &gt; add Test users (emails that you will use in script - Main and Target) </li> <li>Data Access &gt; Add or remove scopes &gt; Scope: .../auth/calendar.events</li> </ul> </li> </ul> </li> </ol>"},{"location":"logging/","title":"Logging","text":"<p>Custom login module. Contain only Logger Class.</p>"},{"location":"logging/#logger_class.Logger","title":"<code>Logger</code>","text":"<p>Custom logging class</p> Class atributes <ul> <li>FILENAME (str): path to where logs are  </li> <li>LEVEL (str | int): Level on which logs will be shown  </li> <li>CONSOLE_LEVEL (str | int): Level on which logs will be shown in console  </li> <li>FILE_LEVEL (str | int): Level on which logs will be appended to file  </li> </ul> Logging Levels <ol> <li>DEBUG (10): Detailed information for programmer.  </li> <li>INFO (20): Information that program works as expected.  </li> <li>WARNING (30): Something happend, but software still works.  </li> <li>ERROR (40): Serious problem.  </li> <li>CRITICAL (50): Probably program won't be able to run.  </li> </ol> Usage <p>Import Logger class from logger_class Call class Looger() and use provided method. In methods use only args or only kwargs.  </p> Example <p>from logger_class import Logger  </p> <p>Logger().debug(kwargs=dict) Logger().info(\"Info message\") Logger().warning(name, \"Warning message\") Logger().error(\"Error message\") Logger().critical(\"Critical message\")</p> Source code in <code>logger_class.py</code> <pre><code>class Logger:\n    \"\"\"Custom logging class\n\n    Class atributes:\n        - FILENAME (str): path to where logs are  \n        - LEVEL (str | int): Level on which logs will be shown  \n        - CONSOLE_LEVEL (str | int): Level on which logs will be shown in console  \n        - FILE_LEVEL (str | int): Level on which logs will be appended to file  \n\n    Logging Levels:\n        1. DEBUG (10): Detailed information for programmer.  \n        2. INFO (20): Information that program works as expected.  \n        3. WARNING (30): Something happend, but software still works.  \n        4. ERROR (40): Serious problem.  \n        5. CRITICAL (50): Probably program won't be able to run.  \n\n    Usage:\n        Import Logger class from logger_class  \n        Call class Looger() and use provided method.  \n        In methods use only args or only kwargs.  \n\n    Example:\n        from logger_class import Logger  \n        &gt;&gt;&gt; Logger().debug(kwargs=dict)  \n        &gt;&gt;&gt; Logger().info(\"Info message\")  \n        &gt;&gt;&gt; Logger().warning(__name__, \"Warning message\")  \n        &gt;&gt;&gt; Logger().error(\"Error message\")  \n        &gt;&gt;&gt; Logger().critical(\"Critical message\")  \n    \"\"\"\n\n    folder_path = Path(__file__).parent.resolve()\n    log_file_path = folder_path / FILENAME\n    if not log_file_path.exists():\n        raise FileNotFoundError(f\"Configuration file not found at {log_file_path}\")\n\n    logger = logging.getLogger()\n    logger.setLevel(LEVEL)\n\n    # configuring log format with timestamp in ISO8601\n    formatter = logging.Formatter(\n        \"%(asctime)s.%(msecs)03dZ - %(levelname)s: %(message)s\",\n        style=\"%\",\n        datefmt=\"%Y-%m-%dT%H:%M:%S\",\n    )\n\n    # create console handler\n    console_handler = logging.StreamHandler()\n    console_handler.setLevel(CONSOLE_LEVEL)\n    console_handler.setFormatter(formatter)\n    logger.addHandler(console_handler)\n\n    # create a rotating file handler with a max size of 10MB and a backup count of 5\n    file_handler = RotatingFileHandler(\n        log_file_path, maxBytes=1024 * 1024 * 10, backupCount=5, encoding=\"utf-8\"\n    )\n    file_handler.setLevel(FILE_LEVEL)\n    file_handler.setFormatter(formatter)\n    logger.addHandler(file_handler)\n\n    @classmethod\n    def debug(cls, *text: str, **kwargs: dict) -&gt; None:\n        \"\"\"Log debug method\"\"\"\n        if kwargs:\n            cls.logger.debug(kwargs.get(\"kwargs\", kwargs))\n        elif text:\n            log_text = \" \".join(text).strip()\n            cls.logger.debug(log_text)\n        else:\n            cls.logger.debug(\"Debug level log\")\n\n    @classmethod\n    def info(cls, *text: str, **kwargs: dict) -&gt; None:\n        \"\"\"Log info method\"\"\"\n        if kwargs:\n            cls.logger.info(kwargs.get(\"kwargs\", kwargs))\n        else:\n            log_text = \" \".join(text).strip()\n            cls.logger.info(log_text)\n\n    @classmethod\n    def warning(cls, *text: str, **kwargs: dict) -&gt; None:\n        \"\"\"Log warning method\"\"\"\n        if kwargs:\n            cls.logger.warning(kwargs.get(\"kwargs\", kwargs))\n        else:\n            log_text = \" \".join(text).strip()\n            cls.logger.warning(log_text)\n\n    @classmethod\n    def error(cls, *text: str, **kwargs: dict) -&gt; None:\n        \"\"\"Log error method\"\"\"\n        if kwargs:\n            cls.logger.error(kwargs.get(\"kwargs\", kwargs))\n        else:\n            log_text = \" \".join(text).strip()\n            cls.logger.error(log_text, exc_info=True)\n\n    @classmethod\n    def critical(cls, *text: str, **kwargs: dict) -&gt; None:\n        \"\"\"Log critical method\"\"\"\n        if kwargs:\n            cls.logger.critical(kwargs.get(\"kwargs\", kwargs))\n        else:\n            log_text = \" \".join(text).strip()\n            cls.logger.critical(log_text)\n</code></pre>"},{"location":"logging/#logger_class.Logger.critical","title":"<code>critical(*text, **kwargs)</code>  <code>classmethod</code>","text":"<p>Log critical method</p> Source code in <code>logger_class.py</code> <pre><code>@classmethod\ndef critical(cls, *text: str, **kwargs: dict) -&gt; None:\n    \"\"\"Log critical method\"\"\"\n    if kwargs:\n        cls.logger.critical(kwargs.get(\"kwargs\", kwargs))\n    else:\n        log_text = \" \".join(text).strip()\n        cls.logger.critical(log_text)\n</code></pre>"},{"location":"logging/#logger_class.Logger.debug","title":"<code>debug(*text, **kwargs)</code>  <code>classmethod</code>","text":"<p>Log debug method</p> Source code in <code>logger_class.py</code> <pre><code>@classmethod\ndef debug(cls, *text: str, **kwargs: dict) -&gt; None:\n    \"\"\"Log debug method\"\"\"\n    if kwargs:\n        cls.logger.debug(kwargs.get(\"kwargs\", kwargs))\n    elif text:\n        log_text = \" \".join(text).strip()\n        cls.logger.debug(log_text)\n    else:\n        cls.logger.debug(\"Debug level log\")\n</code></pre>"},{"location":"logging/#logger_class.Logger.error","title":"<code>error(*text, **kwargs)</code>  <code>classmethod</code>","text":"<p>Log error method</p> Source code in <code>logger_class.py</code> <pre><code>@classmethod\ndef error(cls, *text: str, **kwargs: dict) -&gt; None:\n    \"\"\"Log error method\"\"\"\n    if kwargs:\n        cls.logger.error(kwargs.get(\"kwargs\", kwargs))\n    else:\n        log_text = \" \".join(text).strip()\n        cls.logger.error(log_text, exc_info=True)\n</code></pre>"},{"location":"logging/#logger_class.Logger.info","title":"<code>info(*text, **kwargs)</code>  <code>classmethod</code>","text":"<p>Log info method</p> Source code in <code>logger_class.py</code> <pre><code>@classmethod\ndef info(cls, *text: str, **kwargs: dict) -&gt; None:\n    \"\"\"Log info method\"\"\"\n    if kwargs:\n        cls.logger.info(kwargs.get(\"kwargs\", kwargs))\n    else:\n        log_text = \" \".join(text).strip()\n        cls.logger.info(log_text)\n</code></pre>"},{"location":"logging/#logger_class.Logger.warning","title":"<code>warning(*text, **kwargs)</code>  <code>classmethod</code>","text":"<p>Log warning method</p> Source code in <code>logger_class.py</code> <pre><code>@classmethod\ndef warning(cls, *text: str, **kwargs: dict) -&gt; None:\n    \"\"\"Log warning method\"\"\"\n    if kwargs:\n        cls.logger.warning(kwargs.get(\"kwargs\", kwargs))\n    else:\n        log_text = \" \".join(text).strip()\n        cls.logger.warning(log_text)\n</code></pre>"},{"location":"main/","title":"Main","text":"<p>Calendar Synchronization aplication.</p> <p>This application synchronizes events between two Google Calendar accounts. It uses Google Calendar API to create a webhook for receiving notifications about events. When an event is created, updated, or deleted in the master calendar, then the application will synchronize the changes in the target calendar.  </p> <p>This application is designed to work with flask, that's why it calls app.run() when name == \"main\".  </p> Functions to be performed by the application <ol> <li>Automatically generate tokens when they are missing or expired.  </li> <li>Create a webhook with google calendar API.  </li> <li>Retrieve the list of events that has been changed in last 10 seconds     from master calendar upon receipt of the webhook  </li> <li>Script won't create an event in the target calendar if:  <ul> <li>the event type is not \"default\" (e.g. \"workingLocation\", \"birthday\" etc.)  </li> <li>both calendars are in the event as attendees  </li> <li>webhook was received faster than a second after the last operation  </li> </ul> </li> <li>Checking the status of the event:  <ul> <li>adding a new event to the target calendar if it was created by the owner     or appeared as a guest  </li> <li>remove the event from the target calendar if the event is \u201ccancelled\u201d     or the invitation was not accepted  </li> <li>update the event in the target calendar if it already exists  </li> </ul> </li> <li>Script modyfies color and the event summary by adding a prefix according to the config file    and adds info in the description about the script that created the event.  </li> </ol> How to use script <ul> <li>create Google Cloud project (example https://developers.google.com/people/quickstart/python)  <ul> <li>enable Google Calendar API</li> <li>create desktop client</li> <li>download credentials as credentials.json</li> </ul> </li> <li>configure app with config.ini</li> <li>create tokens<ul> <li>start project.py on your own serwer or</li> <li>run python project_config_class.py if you are using external services and copy tokens</li> </ul> </li> <li>run your own HTTPS serwer (for example use nginx) or run it on external service like     PythonAnywhere.com<ul> <li>in PythonAnywhere configure flask serwer</li> <li>copy all files and folders to /home/username/mysite - rename project.py to flask_app.py</li> </ul> </li> <li>test it</li> </ul> Required pip modules <ul> <li>flask                     (pip install flask)</li> <li>google-api-python-client  (pip install google-api-python-client)</li> <li>google-auth-httplib2      (pip install google-auth-httplib2)</li> <li>google-auth-oauthlib      (pip install google-auth-oauthlib)</li> <li>validator-collection      (pip install validator-collection)</li> </ul> The module contains the following functions <ul> <li>time_now_minus_seconds_iso(time_now, seconds) -      Checks actual time and subtract from it 10 seconds.  </li> <li>check_if_event_type_is_default(event) -      Checks if the event type is 'default'.  </li> <li>check_what_to_do_with_event(target_event, status, response_status) -      Check conditionals and return str with info what to do with event.  </li> </ul> <p>Additional info: I'm using MyPy, if library does not have type hints, then I use # type: ignore[...]</p>"},{"location":"main/#project.check_if_event_type_is_default","title":"<code>check_if_event_type_is_default(event)</code>","text":"<p>Checks if the event type is 'default'.</p> Possible event types <ul> <li>'default'</li> <li>'workingLocation'</li> <li>'birthday'</li> <li>'outOfOffice'</li> <li>'focusTime'</li> <li>'fromGmail'</li> </ul> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>dict</code> <p>The event data dictionary.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if event is default, False otherwise.</p> Source code in <code>project.py</code> <pre><code>def check_if_event_type_is_default(event: dict) -&gt; bool:\n    \"\"\"Checks if the event type is 'default'.\n\n    Possible event types:\n        - 'default'\n        - 'workingLocation'\n        - 'birthday'\n        - 'outOfOffice'\n        - 'focusTime'\n        - 'fromGmail'\n\n    Args:\n        event: The event data dictionary.\n\n    Returns:\n        True if event is default, False otherwise.\n    \"\"\"\n\n    event_type = event.get(\"eventType\")\n    return bool(event_type == \"default\")\n</code></pre>"},{"location":"main/#project.check_what_to_do_with_event","title":"<code>check_what_to_do_with_event(target_event, status, response_status)</code>","text":"<p>Check conditionals and return str with info what to do with event.</p> <p>Parameters:</p> Name Type Description Default <code>target_event</code> <code>Optional[dict]</code> <p>If target event exists, then it's a dict. Else -&gt; None</p> required <code>status</code> <code>str</code> <p>status of the event. Options: \"confirmed\", \"tentative\" or \"cancelled\"</p> required <code>response_status</code> <code>Optional[str]</code> <p>string if attendees are in event contains invitation response status.  Else -&gt; None</p> required <p>Returns:</p> Type Description <code>str</code> <p>\"create\", \"delete\" or \"update\"</p> Source code in <code>project.py</code> <pre><code>def check_what_to_do_with_event(\n    target_event: Optional[dict], status: str, response_status: Optional[str]\n) -&gt; str:\n    \"\"\"Check conditionals and return str with info what to do with event.\n\n    Args:\n        target_event: If target event exists, then it's a dict. Else -&gt; None\n        status: status of the event. Options: \"confirmed\", \"tentative\" or \"cancelled\"\n        response_status: string if attendees are in event contains invitation response status. \n            Else -&gt; None\n\n    Returns:\n        \"create\", \"delete\" or \"update\"\n    \"\"\"\n\n    if not target_event and status != \"cancelled\" and response_status != \"declined\":\n        return \"create\"\n    if target_event and (status == \"cancelled\" or response_status == \"declined\"):\n        return \"delete\"\n    return \"update\"\n</code></pre>"},{"location":"main/#project.main","title":"<code>main()</code>","text":"<p>Main function. It's called when webhook is received.</p> <p>Returns:</p> Type Description <code>str</code> <p>HTTP status code</p> Source code in <code>project.py</code> <pre><code>@app.route(\"/notifications\", methods=[\"POST\"])  # type: ignore\ndef main() -&gt; str:\n    \"\"\"Main function. It's called when webhook is received.\n\n    Returns:\n        HTTP status code\n    \"\"\"\n\n    global CREDENTIALS\n    global TARGET_CREDENTIALS\n    global LAST_UPDATE_TIMESTAMP\n\n    time_now = datetime.now(timezone.utc)\n    resource_state = NotificationChannel.validate_post_request(\n        time_now, LAST_UPDATE_TIMESTAMP\n    )\n    if resource_state != \"exists\":\n        return resource_state\n\n    # If resource_state == \"exists\", then update LAST_UPDATE_TIMESTAMP and last modified events\n    LAST_UPDATE_TIMESTAMP = time_now\n    try:\n        # Building the service to retrieve events from main calendar\n        service = build(\n            \"calendar\", \"v3\", credentials=CREDENTIALS, cache_discovery=False\n        )\n        # Building the service to create, update, or delete events in target calendar\n        target_service = build(\n            \"calendar\", \"v3\", credentials=TARGET_CREDENTIALS, cache_discovery=False\n        )\n    except HttpError as error:\n        Logger().error(f\"An error occurred during building the service: {error}\")\n        return \"500\"  # Internal Server Error\n\n    page_token = \"\"\n\n    while True:\n        # Retrieve the list of events from the master calendar\n        # that has been changed in last 10 seconds\n        try:\n            events_result = (\n                service.events()  # type: ignore\n                .list(\n                    calendarId=config.calendar_id,\n                    updatedMin=time_now_minus_seconds_iso(time_now, seconds=10),\n                    singleEvents=False,\n                    maxResults=250,\n                    pageToken=page_token,\n                )\n                .execute()\n            )\n        except Exception as e:\n            Logger().error(f\"An error occurred while retrieving events: {e}\")\n            return \"500\"\n        events = events_result.get(\"items\", [])\n        if events:\n            for event in events:\n                # For debugging print whole event.\n                Logger().debug(f\"Checking event: {event}\")\n                event_data = EventData()\n\n                # Check if event type is default.\n                if not check_if_event_type_is_default(event):  # type: ignore[arg-type]\n                    Logger().info(\n                        f\"Event ID: {event.get('id')}, summary: {event.get('summary')} \"\n                        f\"Event type is not default: {event.get('eventType')}. Skip.\"\n                    )\n                    continue\n                # Check if CALENDAR_ID and TARGET_CALENDAR_ID are attendees in event.\n                if event_data.check_calendars_in_attendees(event, config) == \"Both\":  # type: ignore\n                    Logger().info(\n                        f\"Event ID: {event.get('id')}, summary: {event.get('summary')} \"\n                        \"Both calendars are in the event. Skip.\"\n                    )\n                    continue\n\n                event_id = event.get(\"id\", \"\")\n                status = event.get(\"status\", \"\")\n                target_event = event_data.check_if_id_exists_in_target_calendar(\n                    event_id, target_service, config\n                )\n                response_status = event_data.get_attendee_response_status(\n                    event, config.calendar_id  # type: ignore[arg-type]\n                )\n                match check_what_to_do_with_event(target_event, status, response_status):\n                    # If event doesn't exists in Target Calendar and it's not been cancelled or\n                    # declined then create new one in Target Calendar.\n                    case \"create\":\n                        Logger().info(\n                            f\"Event ID: {event['id']}, summary: {event['summary']}. \"\n                            \"Creating new event.\"\n                        )\n                        event_data.get_event_details(event, config)  # type: ignore[arg-type]\n                        event_data.pop_unnecessary_keys()\n                        event_data.create_new_event(\n                            config.target_calendar_id, target_service\n                        )\n                        continue\n\n                    # If event does exists in Target Calendar and it is cancelled or declined\n                    # then delete event in Target Calendar.\n                    case \"delete\":\n                        Logger().info(\n                            f\"Event ID: {event['id']}, summary: {event['summary']}. \"\n                            \"Deleting event.\"\n                        )\n                        event_data.delete_event(\n                            config.target_calendar_id, event_id, target_service\n                        )\n                        continue\n\n                    # If event does exists in Target Calendar and it's not been cancelled or\n                    # declined then update event in Target Calendar.\n                    case \"update\":\n                        Logger().info(\n                            f\"Event ID: {event['id']}, summary: {event['summary']}. \"\n                            \"Updating event.\"\n                        )\n                        event_data.get_event_details(event, config)  # type: ignore[arg-type]\n                        event_data.pop_unnecessary_keys()\n                        event_data.update_event(target_service, event_id, config)\n        # Check if there is more events using 'nextPageToken\n        page_token = events_result.get(\"nextPageToken\", \"\")\n        if not page_token:\n            break\n    return \"200\"  # OK\n</code></pre>"},{"location":"main/#project.time_now_minus_seconds_iso","title":"<code>time_now_minus_seconds_iso(time_now, seconds=10)</code>","text":"<p>Checks actual time and subtract from it given seconds.</p> <p>It's used for getting list of events.</p> <p>Parameters:</p> Name Type Description Default <code>time_now</code> <code>datetime</code> <p>The current time when the request is received.</p> required <code>seconds</code> <code>int</code> <p>Amount of seconds is being substracted from actual time</p> <code>10</code> <p>Returns:</p> Type Description <code>str</code> <p>Actual time minus given time in seconds. In ISO format.</p> Source code in <code>project.py</code> <pre><code>def time_now_minus_seconds_iso(time_now: datetime, seconds: int = 10) -&gt; str:\n    \"\"\"Checks actual time and subtract from it given seconds.\n\n    It's used for getting list of events.\n\n    Args:\n        time_now: The current time when the request is received.\n        seconds: Amount of seconds is being substracted from actual time\n\n    Returns:\n        Actual time minus given time in seconds. In ISO format.\n    \"\"\"\n\n    now_minus_x_seconds = time_now - timedelta(seconds=seconds)\n    return now_minus_x_seconds.isoformat()\n</code></pre>"},{"location":"notification_channel/","title":"Notification Channel Class","text":"<p>NotificationChannel Class module</p> <p>This module manages notification channels for Google Calendar API.</p>"},{"location":"notification_channel/#project_notification_channel_class.NotificationChannel","title":"<code>NotificationChannel</code>","text":"<p>Class to manage notification channels for Google Calendar API.</p> <p>This class allows creating a notification channel for a specific calendar and validating POST requests sent to the webhook URL. It generates a unique channel ID and handles the creation of the channel.  </p> <p>Attributes:</p> Name Type Description <code>calendar_id</code> <code>str</code> <p>The ID of the calendar to create the notification channel for.</p> <code>webhook_url</code> <code>str</code> <p>The URL to which notifications will be sent.</p> <code>auth_token</code> <code>str</code> <p>The OAuth 2.0 token for authentication.</p> <code>channel_id</code> <code>str</code> <p>A unique identifier for the notification channel, generated using UUID.</p> This class contains following methods <ul> <li>create_notification_channel() -      Creates a notification channel for given calendar and returns the response from         the Google Calendar API.</li> <li>validate_post_request(time_now, last_update_timestamp) -      Validates the POST request for the notification channel based on the current time         and last update timestamp.</li> </ul> Source code in <code>project_notification_channel_class.py</code> <pre><code>class NotificationChannel:\n    \"\"\"Class to manage notification channels for Google Calendar API.\n\n    This class allows creating a notification channel for a specific calendar\n    and validating POST requests sent to the webhook URL.  \n    It generates a unique channel ID and handles the creation of the channel.  \n\n    Attributes:\n        calendar_id (str): The ID of the calendar to create the notification channel for.\n        webhook_url (str): The URL to which notifications will be sent.\n        auth_token (str): The OAuth 2.0 token for authentication.\n        channel_id (str): A unique identifier for the notification channel, generated using UUID.\n\n    This class contains following methods:\n        - create_notification_channel() - \n            Creates a notification channel for given calendar and returns the response from\n                the Google Calendar API.\n        - validate_post_request(time_now, last_update_timestamp) - \n            Validates the POST request for the notification channel based on the current time\n                and last update timestamp.\n    \"\"\"\n\n    def __init__(self, calendar_id: str, webhook_url: str, auth_token: str):\n        \"\"\"Initialize an instance.\n\n        Args:\n            calendar_id: The ID of the calendar to create the notification channel for\n                                Expected format: email address\n            webhook_url: The URL to which notifications will be sent\n                                Expected format: HTTPS URL\n            auth_token: The OAuth 2.0 token for authentication\n            channel_id (str): A unique identifier for the notification channel, generated using UUID\n        \"\"\"\n\n        self.calendar_id = calendar_id\n        self.webhook_url = webhook_url\n        self.auth_token = auth_token\n        self.channel_id = str(uuid.uuid4())  # Generate a unique channel ID\n\n    def create_notification_channel(self) -&gt; dict:\n        \"\"\"Creates a notification channel for a given calendar.\n\n        This method sends a POST request to the Google Calendar API to create a notification channel\n\n        Returns:\n            Json response from the Google Calendar API.  \n                If the request is successful (HTTP status code 200), the response contains\n                    details of the created channel.  \n                If the request fails, the response contains an error message.\n        \"\"\"\n\n        url = f\"https://www.googleapis.com/calendar/v3/calendars/{self.calendar_id}/events/watch\"\n        headers = {\n            \"Authorization\": f\"Bearer {self.auth_token}\",\n            \"Content-Type\": \"application/json\",\n        }\n        payload = {\n            \"id\": self.channel_id,\n            \"type\": \"web_hook\",\n            \"address\": self.webhook_url,\n        }\n\n        response = requests.post(url, headers=headers, json=payload, timeout=2)\n\n        if response.status_code == 200:\n            Logger().info(\"Notification channel created successfully!\", __name__)\n            Logger().debug(kwargs=response.json())\n            return response.json()\n        Logger().info(\"Notification channel HAS NOT BEEN created.\", __name__)\n        Logger().warning(kwargs=response.json())\n        return response.json()\n\n    @staticmethod\n    def validate_post_request(\n        time_now: datetime, last_update_timestamp: datetime\n    ) -&gt; str:\n        \"\"\"Validates the POST request for the notification channel.\n\n        This method checks if the request is valid based on the current time\n            and the last update timestamp.  \n        It ensures that the request method is POST and checks the resource state in the headers.  \n\n        Args:\n            time_now: The current time when the request is received.\n            last_update_timestamp: The timestamp of the last update.\n\n        Returns:\n            Resource state if == \"exists'.\n            HTTP status code indicating the result of the validation.\n        \"\"\"\n\n        if last_update_timestamp &gt; (time_now - timedelta(seconds=1)):\n            Logger().debug(\"208 - Already Reported\", __name__)\n            return \"208\"  # Already Reported\n        if request.method != \"POST\":\n            Logger().warning(\"405 - Method Not Allowed\", __name__)\n            return \"405\"  # Method Not Allowed\n\n        # print(f\"Full headers: {request.headers}\")  # Keep for debugging\n        resource_state = request.headers.get(\"X-Goog-Resource-State\")\n        if resource_state == \"sync\":\n            Logger().debug(\"This is a sync message.\", __name__)\n            return \"200\"  # OK\n        if resource_state == \"exists\":\n            return \"exists\"\n        if resource_state is None:\n            Logger().warning(\"No resource state in headers.\", __name__)\n            return \"400\"  # Bad Request\n        Logger().warning(\n            f\"Resource state: {resource_state}. \"\n            \"Waiting for resource state == 'exists'.\", __name__\n        )\n        return \"202\"  # Accepted, waiting for resource state to be 'exists'\n</code></pre>"},{"location":"notification_channel/#project_notification_channel_class.NotificationChannel.__init__","title":"<code>__init__(calendar_id, webhook_url, auth_token)</code>","text":"<p>Initialize an instance.</p> <p>Parameters:</p> Name Type Description Default <code>calendar_id</code> <code>str</code> <p>The ID of the calendar to create the notification channel for                 Expected format: email address</p> required <code>webhook_url</code> <code>str</code> <p>The URL to which notifications will be sent                 Expected format: HTTPS URL</p> required <code>auth_token</code> <code>str</code> <p>The OAuth 2.0 token for authentication</p> required <code>channel_id</code> <code>str</code> <p>A unique identifier for the notification channel, generated using UUID</p> required Source code in <code>project_notification_channel_class.py</code> <pre><code>def __init__(self, calendar_id: str, webhook_url: str, auth_token: str):\n    \"\"\"Initialize an instance.\n\n    Args:\n        calendar_id: The ID of the calendar to create the notification channel for\n                            Expected format: email address\n        webhook_url: The URL to which notifications will be sent\n                            Expected format: HTTPS URL\n        auth_token: The OAuth 2.0 token for authentication\n        channel_id (str): A unique identifier for the notification channel, generated using UUID\n    \"\"\"\n\n    self.calendar_id = calendar_id\n    self.webhook_url = webhook_url\n    self.auth_token = auth_token\n    self.channel_id = str(uuid.uuid4())  # Generate a unique channel ID\n</code></pre>"},{"location":"notification_channel/#project_notification_channel_class.NotificationChannel.create_notification_channel","title":"<code>create_notification_channel()</code>","text":"<p>Creates a notification channel for a given calendar.</p> <p>This method sends a POST request to the Google Calendar API to create a notification channel</p> <p>Returns:</p> Type Description <code>dict</code> <p>Json response from the Google Calendar API. If the request is successful (HTTP status code 200), the response contains     details of the created channel. If the request fails, the response contains an error message.</p> Source code in <code>project_notification_channel_class.py</code> <pre><code>def create_notification_channel(self) -&gt; dict:\n    \"\"\"Creates a notification channel for a given calendar.\n\n    This method sends a POST request to the Google Calendar API to create a notification channel\n\n    Returns:\n        Json response from the Google Calendar API.  \n            If the request is successful (HTTP status code 200), the response contains\n                details of the created channel.  \n            If the request fails, the response contains an error message.\n    \"\"\"\n\n    url = f\"https://www.googleapis.com/calendar/v3/calendars/{self.calendar_id}/events/watch\"\n    headers = {\n        \"Authorization\": f\"Bearer {self.auth_token}\",\n        \"Content-Type\": \"application/json\",\n    }\n    payload = {\n        \"id\": self.channel_id,\n        \"type\": \"web_hook\",\n        \"address\": self.webhook_url,\n    }\n\n    response = requests.post(url, headers=headers, json=payload, timeout=2)\n\n    if response.status_code == 200:\n        Logger().info(\"Notification channel created successfully!\", __name__)\n        Logger().debug(kwargs=response.json())\n        return response.json()\n    Logger().info(\"Notification channel HAS NOT BEEN created.\", __name__)\n    Logger().warning(kwargs=response.json())\n    return response.json()\n</code></pre>"},{"location":"notification_channel/#project_notification_channel_class.NotificationChannel.validate_post_request","title":"<code>validate_post_request(time_now, last_update_timestamp)</code>  <code>staticmethod</code>","text":"<p>Validates the POST request for the notification channel.</p> <p>This method checks if the request is valid based on the current time     and the last update timestamp. It ensures that the request method is POST and checks the resource state in the headers.  </p> <p>Parameters:</p> Name Type Description Default <code>time_now</code> <code>datetime</code> <p>The current time when the request is received.</p> required <code>last_update_timestamp</code> <code>datetime</code> <p>The timestamp of the last update.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Resource state if == \"exists'.</p> <code>str</code> <p>HTTP status code indicating the result of the validation.</p> Source code in <code>project_notification_channel_class.py</code> <pre><code>@staticmethod\ndef validate_post_request(\n    time_now: datetime, last_update_timestamp: datetime\n) -&gt; str:\n    \"\"\"Validates the POST request for the notification channel.\n\n    This method checks if the request is valid based on the current time\n        and the last update timestamp.  \n    It ensures that the request method is POST and checks the resource state in the headers.  \n\n    Args:\n        time_now: The current time when the request is received.\n        last_update_timestamp: The timestamp of the last update.\n\n    Returns:\n        Resource state if == \"exists'.\n        HTTP status code indicating the result of the validation.\n    \"\"\"\n\n    if last_update_timestamp &gt; (time_now - timedelta(seconds=1)):\n        Logger().debug(\"208 - Already Reported\", __name__)\n        return \"208\"  # Already Reported\n    if request.method != \"POST\":\n        Logger().warning(\"405 - Method Not Allowed\", __name__)\n        return \"405\"  # Method Not Allowed\n\n    # print(f\"Full headers: {request.headers}\")  # Keep for debugging\n    resource_state = request.headers.get(\"X-Goog-Resource-State\")\n    if resource_state == \"sync\":\n        Logger().debug(\"This is a sync message.\", __name__)\n        return \"200\"  # OK\n    if resource_state == \"exists\":\n        return \"exists\"\n    if resource_state is None:\n        Logger().warning(\"No resource state in headers.\", __name__)\n        return \"400\"  # Bad Request\n    Logger().warning(\n        f\"Resource state: {resource_state}. \"\n        \"Waiting for resource state == 'exists'.\", __name__\n    )\n    return \"202\"  # Accepted, waiting for resource state to be 'exists'\n</code></pre>"},{"location":"tutorials/","title":"Basics","text":"<p>This tutorial shows easy way to get thing running.  </p>"},{"location":"tutorials/#requirements","title":"Requirements","text":"<p>Python 3.10     Check your version:      <code>python --version</code></p>"},{"location":"tutorials/#set-up-virtual-environment","title":"Set up virtual environment","text":"<p>Install virtual env. <code>python -m venv venv</code> Start virtual env. <code>.\\venv\\Scripts\\activate</code></p>"},{"location":"tutorials/#install-packages","title":"Install packages","text":"<p><code>pip install -r requirements.txt</code></p>"},{"location":"tutorials/#configure","title":"Configure","text":"<p>Edit file config.ini. Description of variables. Don't use quotes, scopes have to be in parenthesis [ ].</p> VARIABLE EXAMPLE DESCRIPTION SCOPES [\"https://www.googleapis.com/auth/calendar.events\"] List of scopes, to use this program you don't have to change it CALENDAR_ID username@gmail.com Main calendar e-mail address, don't use 'primary' it will cause issues when checking the 'responseStatus' of attendees. TARGET_CALENDAR_ID 73c4p8b3qdk82jnof68@group.calendar.google.com Target calendar to where events are copied. WEBHOOK_URL https://username.pythonanywhere.com/notifications URL to where your program is instantiated. Must be HTTPS! for webhook to work. TOKEN_PATH credentials\\token.json Path to CALENDAR_ID token. Need to login with Google OAUTH. TARGET_TOKEN_PATH credentials\\target_token.json Path to TARGET_CALENDAR_ID token. Need to login with Google OAUTH. CREDENTIALS_PATH credentials\\credentials.json Credentials downloaded from Google Cloud https://console.cloud.google.com/auth/clients GOOGLE_APPLICATION_CREDENTIALS /home/username/your-file.json Path to Google CLoud service account key. SAME_USER True / False Bool. If Target calendar is sub calendar for Main calendar then use True. Otherwise use False. PREFIX [WORK] Prefix that will be added to summary. COLOR 9 Integer from range 0-11. 0 means default for Target calendar. SUFFIX This event was created by Google Calendar Sync script.  Made by wolk.tomasz@gmail.com Suffix added to description."},{"location":"tutorials/#create-tokens","title":"Create tokens","text":"<p>Create Google Cloud project (example https://developers.google.com/people/quickstart/python).</p> <ul> <li>Enable Google Calendar API</li> <li>In \"Audience\" add users - primary emails for Main and Target Calendars</li> <li>In \"Data Access\" add Scope: \"./auth/calendar.events\"</li> <li>In \"Clients\" create OAuth 2.0 desktop client and download credentials.json to folder credentials.</li> </ul> <p>Run <code>python .\\utils\\project_config_class.py</code> </p> <p>Log to your accounts using OAuth:</p> <ul> <li>First log to Main calendar (from where events will be copied).  </li> <li>Second log to Target calendar (to where event will be copied).       If 'SAME_USER = True' then second logging will be skiped.  </li> </ul>"},{"location":"tutorials/#run-serwer-with-https-and-start-program","title":"Run serwer with HTTPS and start program.","text":"<p>You can use external serwer, example PythonAnywhere.com. Create flask serwer and copy files to /home/username/mysite/ Remember to change name of project.py to flask_app.py and change in config.ini  WEBHOOK_URL to your url.</p>"},{"location":"tutorials/#graph-showing-how-script-works","title":"Graph showing how script works.","text":"<pre><code>graph TD\n    A[Webhook Notification] --&gt; B(Validate Request)\n    B --&gt;|Last update &gt; current time + 1s| 208[Return 208 &lt;br&gt; Already Reported]\n    B --&gt;|Request != POST| 405[Return 405 &lt;br&gt; Method not allowed]\n    B --&gt;|Request == POST| C{Resource State Check}\n    C --&gt;|Sync| 200[Return 200 &lt;br&gt; OK]\n    C --&gt;|Exists| D[Update Timestamp]\n    C --&gt;|None| E[Return 400 &lt;br&gt; Bad Request]\n    D --&gt; S[Build Services]\n    S --&gt; F[Retrieve Events]\n    F --&gt;|Events Found| G[Process Events]\n    G --&gt; H{Check Event Type}\n    H --&gt;|Default| J[Check Attendees]\n    H --&gt;|Not Default| I[Skip Event]\n    J --&gt;|Both Present| K[Skip Event]\n    J --&gt;|Not Both Present| M{What to do?}\n    M --&gt;|Event Do Not Exists in Target Calendar &lt;br&gt; Status != Cancelled &lt;br&gt; Response status != Declined| N[Create Event]\n    M --&gt;|Event Exists in Target Calendar &lt;br&gt; Status == Cancelled or &lt;br&gt; Response status == Declined| O[Delete Event]\n    M --&gt;|Event Exists in Target Calendar &lt;br&gt; Status != Cancelled &lt;br&gt; Response status != Declined| P[Update Event]\n    F --&gt;|No More Events| Q[Return]\n    N --&gt; R{Check for more events}\n    O --&gt; R{Check for more events}\n    P --&gt; R{Check for more events}\n    R --&gt; |Event found| G\n    R --&gt; |No more events found| T[Exit]\n</code></pre>"},{"location":"tutorials/#directory-tree","title":"Directory tree","text":"<pre><code>CS50 Python Final Project\n|\n|   test_project.py\n|   project.py\n|   config.ini\n|   requirements.txt\n|   project_notification_channel_class.py\n|   project_config_class.py\n|   project_event_data.py\n|   logger_class.py\n|   credentials.json\n|   token.json\n|   target_token.json\n|\n+---logs\n        app.log\n</code></pre>"}]}